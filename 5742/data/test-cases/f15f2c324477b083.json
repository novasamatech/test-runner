{"uid":"f15f2c324477b083","name":"test_rpc_node_is_synced[Test for Ethereum, url: https://1rpc.io/eth]","fullName":"tests.test_eth_nodes_availability.TestETHNodesAvailability#test_rpc_node_is_synced","historyId":"9e0c16e1a7876bd51b49d655a0298c26","time":{"start":1727795075199,"stop":1727795105510,"duration":30311},"status":"broken","statusMessage":"asyncio.exceptions.TimeoutError","statusTrace":"self = <websockets.legacy.client.WebSocketClientProtocol object at 0x7f8b02faecb0>\n\n    async def recv(self) -> Data:\n        \"\"\"\n        Receive the next message.\n    \n        When the connection is closed, :meth:`recv` raises\n        :exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it raises\n        :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal\n        connection closure and\n        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol\n        error or a network failure. This is how you detect the end of the\n        message stream.\n    \n        Canceling :meth:`recv` is safe. There's no risk of losing the next\n        message. The next invocation of :meth:`recv` will return it.\n    \n        This makes it possible to enforce a timeout by wrapping :meth:`recv` in\n        :func:`~asyncio.timeout` or :func:`~asyncio.wait_for`.\n    \n        Returns:\n            Data: A string (:class:`str`) for a Text_ frame. A bytestring\n            (:class:`bytes`) for a Binary_ frame.\n    \n            .. _Text: https://www.rfc-editor.org/rfc/rfc6455.html#section-5.6\n            .. _Binary: https://www.rfc-editor.org/rfc/rfc6455.html#section-5.6\n    \n        Raises:\n            ConnectionClosed: When the connection is closed.\n            RuntimeError: If two coroutines call :meth:`recv` concurrently.\n    \n        \"\"\"\n        if self._pop_message_waiter is not None:\n            raise RuntimeError(\n                \"cannot call recv while another coroutine \"\n                \"is already waiting for the next message\"\n            )\n    \n        # Don't await self.ensure_open() here:\n        # - messages could be available in the queue even if the connection\n        #   is closed;\n        # - messages could be received before the closing frame even if the\n        #   connection is closing.\n    \n        # Wait until there's a message in the queue (if necessary) or the\n        # connection is closed.\n        while len(self.messages) <= 0:\n            pop_message_waiter: asyncio.Future[None] = self.loop.create_future()\n            self._pop_message_waiter = pop_message_waiter\n            try:\n                # If asyncio.wait() is canceled, it doesn't cancel\n                # pop_message_waiter and self.transfer_data_task.\n>               await asyncio.wait(\n                    [pop_message_waiter, self.transfer_data_task],\n                    return_when=asyncio.FIRST_COMPLETED,\n                )\n\n.venv/lib/python3.10/site-packages/websockets/legacy/protocol.py:552: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfs = {<Task cancelled name='Task-2' coro=<WebSocketCommonProtocol.transfer_data() done, defined at /home/runner/work/test-runner/test-runner/nova-utils/.venv/lib/python3.10/site-packages/websockets/legacy/protocol.py:954>>, <Future pending>}\n\n    async def wait(fs, *, timeout=None, return_when=ALL_COMPLETED):\n        \"\"\"Wait for the Futures and coroutines given by fs to complete.\n    \n        The fs iterable must not be empty.\n    \n        Coroutines will be wrapped in Tasks.\n    \n        Returns two sets of Future: (done, pending).\n    \n        Usage:\n    \n            done, pending = await asyncio.wait(fs)\n    \n        Note: This does not raise TimeoutError! Futures that aren't done\n        when the timeout occurs are returned in the second set.\n        \"\"\"\n        if futures.isfuture(fs) or coroutines.iscoroutine(fs):\n            raise TypeError(f\"expect a list of futures, not {type(fs).__name__}\")\n        if not fs:\n            raise ValueError('Set of coroutines/Futures is empty.')\n        if return_when not in (FIRST_COMPLETED, FIRST_EXCEPTION, ALL_COMPLETED):\n            raise ValueError(f'Invalid return_when value: {return_when}')\n    \n        loop = events.get_running_loop()\n    \n        fs = set(fs)\n    \n        if any(coroutines.iscoroutine(f) for f in fs):\n            warnings.warn(\"The explicit passing of coroutine objects to \"\n                          \"asyncio.wait() is deprecated since Python 3.8, and \"\n                          \"scheduled for removal in Python 3.11.\",\n                          DeprecationWarning, stacklevel=2)\n    \n        fs = {ensure_future(f, loop=loop) for f in fs}\n    \n>       return await _wait(fs, timeout, return_when, loop)\n\n/usr/lib/python3.10/asyncio/tasks.py:384: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfs = {<Task cancelled name='Task-2' coro=<WebSocketCommonProtocol.transfer_data() done, defined at /home/runner/work/test-runner/test-runner/nova-utils/.venv/lib/python3.10/site-packages/websockets/legacy/protocol.py:954>>, <Future pending>}\ntimeout = None, return_when = 'FIRST_COMPLETED'\nloop = <_UnixSelectorEventLoop running=True closed=False debug=False>\n\n    async def _wait(fs, timeout, return_when, loop):\n        \"\"\"Internal helper for wait().\n    \n        The fs argument must be a collection of Futures.\n        \"\"\"\n        assert fs, 'Set of Futures is empty.'\n        waiter = loop.create_future()\n        timeout_handle = None\n        if timeout is not None:\n            timeout_handle = loop.call_later(timeout, _release_waiter, waiter)\n        counter = len(fs)\n    \n        def _on_completion(f):\n            nonlocal counter\n            counter -= 1\n            if (counter <= 0 or\n                return_when == FIRST_COMPLETED or\n                return_when == FIRST_EXCEPTION and (not f.cancelled() and\n                                                    f.exception() is not None)):\n                if timeout_handle is not None:\n                    timeout_handle.cancel()\n                if not waiter.done():\n                    waiter.set_result(None)\n    \n        for f in fs:\n            f.add_done_callback(_on_completion)\n    \n        try:\n>           await waiter\nE           asyncio.exceptions.CancelledError\n\n/usr/lib/python3.10/asyncio/tasks.py:491: CancelledError\n\nDuring handling of the above exception, another exception occurred:\n\nfut = <Task cancelled name='Task-6' coro=<WebSocketCommonProtocol.recv() done, defined at /home/runner/work/test-runner/test-runner/nova-utils/.venv/lib/python3.10/site-packages/websockets/legacy/protocol.py:502>>\ntimeout = 10\n\n    async def wait_for(fut, timeout):\n        \"\"\"Wait for the single Future or coroutine to complete, with timeout.\n    \n        Coroutine will be wrapped in Task.\n    \n        Returns result of the Future or coroutine.  When a timeout occurs,\n        it cancels the task and raises TimeoutError.  To avoid the task\n        cancellation, wrap it in shield().\n    \n        If the wait is cancelled, the task is also cancelled.\n    \n        This function is a coroutine.\n        \"\"\"\n        loop = events.get_running_loop()\n    \n        if timeout is None:\n            return await fut\n    \n        if timeout <= 0:\n            fut = ensure_future(fut, loop=loop)\n    \n            if fut.done():\n                return fut.result()\n    \n            await _cancel_and_wait(fut, loop=loop)\n            try:\n                return fut.result()\n            except exceptions.CancelledError as exc:\n                raise exceptions.TimeoutError() from exc\n    \n        waiter = loop.create_future()\n        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)\n        cb = functools.partial(_release_waiter, waiter)\n    \n        fut = ensure_future(fut, loop=loop)\n        fut.add_done_callback(cb)\n    \n        try:\n            # wait until the future completes or the timeout\n            try:\n                await waiter\n            except exceptions.CancelledError:\n                if fut.done():\n                    return fut.result()\n                else:\n                    fut.remove_done_callback(cb)\n                    # We must ensure that the task is not running\n                    # after wait_for() returns.\n                    # See https://bugs.python.org/issue32751\n                    await _cancel_and_wait(fut, loop=loop)\n                    raise\n    \n            if fut.done():\n                return fut.result()\n            else:\n                fut.remove_done_callback(cb)\n                # We must ensure that the task is not running\n                # after wait_for() returns.\n                # See https://bugs.python.org/issue32751\n                await _cancel_and_wait(fut, loop=loop)\n                # In case task cancellation failed with some\n                # exception, we should re-raise it\n                # See https://bugs.python.org/issue40607\n                try:\n>                   return fut.result()\nE                   asyncio.exceptions.CancelledError\n\n/usr/lib/python3.10/asyncio/tasks.py:456: CancelledError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_eth_nodes_availability.TestETHNodesAvailability object at 0x7f8b02fadab0>\ndata = {'name': 'Ethereum', 'url': 'https://1rpc.io/eth'}\n\n    def test_rpc_node_is_synced(self, data):\n    \n        wss_w3 = Web3(Web3.WebsocketProvider('wss://mainnet.infura.io/ws/v3/32a2be59297444c9bcb2b61bb700c6fe'))\n        # Check if connected to wss node\n>       assert wss_w3.is_connected(), \"Failed to connect to Ethereum wss node\"\n\ntests/test_eth_nodes_availability.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/web3/main.py:445: in is_connected\n    return self.provider.is_connected()\n.venv/lib/python3.10/site-packages/web3/providers/base.py:110: in is_connected\n    response = self.make_request(RPCEndpoint(\"web3_clientVersion\"), [])\n.venv/lib/python3.10/site-packages/web3/providers/websocket.py:135: in make_request\n    return future.result()\n/usr/lib/python3.10/concurrent/futures/_base.py:458: in result\n    return self.__get_result()\n/usr/lib/python3.10/concurrent/futures/_base.py:403: in __get_result\n    raise self._exception\n.venv/lib/python3.10/site-packages/web3/providers/websocket.py:124: in coro_make_request\n    await asyncio.wait_for(conn.recv(), timeout=self.websocket_timeout)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfut = <Task cancelled name='Task-6' coro=<WebSocketCommonProtocol.recv() done, defined at /home/runner/work/test-runner/test-runner/nova-utils/.venv/lib/python3.10/site-packages/websockets/legacy/protocol.py:502>>\ntimeout = 10\n\n    async def wait_for(fut, timeout):\n        \"\"\"Wait for the single Future or coroutine to complete, with timeout.\n    \n        Coroutine will be wrapped in Task.\n    \n        Returns result of the Future or coroutine.  When a timeout occurs,\n        it cancels the task and raises TimeoutError.  To avoid the task\n        cancellation, wrap it in shield().\n    \n        If the wait is cancelled, the task is also cancelled.\n    \n        This function is a coroutine.\n        \"\"\"\n        loop = events.get_running_loop()\n    \n        if timeout is None:\n            return await fut\n    \n        if timeout <= 0:\n            fut = ensure_future(fut, loop=loop)\n    \n            if fut.done():\n                return fut.result()\n    \n            await _cancel_and_wait(fut, loop=loop)\n            try:\n                return fut.result()\n            except exceptions.CancelledError as exc:\n                raise exceptions.TimeoutError() from exc\n    \n        waiter = loop.create_future()\n        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)\n        cb = functools.partial(_release_waiter, waiter)\n    \n        fut = ensure_future(fut, loop=loop)\n        fut.add_done_callback(cb)\n    \n        try:\n            # wait until the future completes or the timeout\n            try:\n                await waiter\n            except exceptions.CancelledError:\n                if fut.done():\n                    return fut.result()\n                else:\n                    fut.remove_done_callback(cb)\n                    # We must ensure that the task is not running\n                    # after wait_for() returns.\n                    # See https://bugs.python.org/issue32751\n                    await _cancel_and_wait(fut, loop=loop)\n                    raise\n    \n            if fut.done():\n                return fut.result()\n            else:\n                fut.remove_done_callback(cb)\n                # We must ensure that the task is not running\n                # after wait_for() returns.\n                # See https://bugs.python.org/issue32751\n                await _cancel_and_wait(fut, loop=loop)\n                # In case task cancellation failed with some\n                # exception, we should re-raise it\n                # See https://bugs.python.org/issue40607\n                try:\n                    return fut.result()\n                except exceptions.CancelledError as exc:\n>                   raise exceptions.TimeoutError() from exc\nE                   asyncio.exceptions.TimeoutError\n\n/usr/lib/python3.10/asyncio/tasks.py:458: TimeoutError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"afterStages":[],"labels":[{"name":"parentSuite","value":"tests"},{"name":"suite","value":"test_eth_nodes_availability"},{"name":"subSuite","value":"TestETHNodesAvailability"},{"name":"host","value":"fv-az891-78"},{"name":"thread","value":"2119-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_eth_nodes_availability"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"data","value":"{'url': 'https://1rpc.io/eth', 'name': 'Ethereum'}"}],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"f15f2c324477b083.json","parameterValues":["{'url': 'https://1rpc.io/eth', 'name': 'Ethereum'}"]}